<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GraFit</name>
    </assembly>
    <members>
        <member name="M:Grafit.CUtils.ExportMatrixToBinary(System.Int32[][],System.String)">
            <summary>
            Exports an int matrix represented as a jagged array to a binary file.
            </summary>
            <remarks>
            This static method takes a matrix, represented by a jagged array of integers (<paramref name="matrix"/>), and writes its contents
            to a binary file specified by <paramref name="path"/>.
            </remarks>
            <param name="matrix">The jagged array representing the matrix to be exported.</param>
            <param name="path">The file system path where the binary file will be created.</param>
        </member>
        <member name="M:Grafit.CUtils.ExportMatrixToBinary(System.Double[][],System.String)">
            <summary>
            Exports a double matrix represented as a jagged array to a binary file.
            </summary>
            <remarks>
            This static method takes a matrix, represented by a jagged array of doubles (<paramref name="matrix"/>), and writes its contents
            to a binary file specified by <paramref name="path"/>.
            </remarks>
            <param name="matrix">The jagged array representing the matrix to be exported.</param>
            <param name="path">The file system path where the binary file will be created.</param>
        </member>
        <member name="M:Grafit.CUtils.ExportMatrixToBinary(System.Single[][],System.String)">
            <summary>
            Exports a float matrix represented as a jagged array to a binary file.
            </summary>
            <remarks>
            This static method takes a matrix, represented by a jagged array of floats (<paramref name="matrix"/>), and writes its contents
            to a binary file specified by <paramref name="path"/>.
            </remarks>
            <param name="matrix">The jagged array representing the matrix to be exported.</param>
            <param name="path">The file system path where the binary file will be created.</param>
        </member>
        <member name="M:Grafit.CUtils.LoadTestDataDouble(System.String)">
            <summary>
            Loads a double matrix represented as a jagged array from a binary file.
            </summary>
            <remarks>
            This static method takes a path to binary file specified by <paramref name="path"/> and loads a 
            matrix, represented by a jagged array of doubles.
            </remarks> 
            <param name="path">The file system path where the binary file will be created.</param>
            <returns>The jagged array representing the matrix.</returns>
        </member>
        <member name="M:Grafit.CUtils.LoadTestDataInt(System.String)">
            <summary>
            Loads an int matrix represented as a jagged array from a binary file.
            </summary>
            <remarks>
            This static method takes a path to binary file specified by <paramref name="path"/> and loads a 
            matrix, represented by a jagged array of integers.
            </remarks> 
            <param name="path">The file system path where the binary file will be created.</param>
            <returns>The jagged array representing the matrix.</returns>
        </member>
        <member name="T:Grafit.CMeasure">
            <summary>
            The `CMeasure` class offers a suite of methods designed to compute different types of measurements for a graph. 
            </summary> 
        </member>
        <member name="M:Grafit.CMeasure.#ctor(Grafit.IMeasurableGraph)">
            <summary>
            Initializes a new instance of the CMeasure class for a given graph.
            </summary>
            <param name="Graph">The graph on which measurements will be performed. It must implement the `IMeasurableGraph` interface.</param> 
            <example>
            <code>
            var measurement = new CMeasure(graph); 
            </code>
            </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateBC(System.Double[][],System.Boolean)">
             <summary>
             Calculates the betweenness centrality for both nodes (`BCNodes`) and edges (`BCEdges`) in the graph.
             </summary>
             <param name="ODWeightMatrix">The origin-destination weight matrix representing the weights of the shortest paths between all pairs of nodes.</param>
             <param name="GPU">A boolean indicating if GPU acceleration should be utilized. Set to <c>true</c> for GPU computation.</param>
             <remarks>
             Betweenness centrality measures the importance of nodes and edges based on their participation in the shortest paths across the graph.
             
             The betweenness centrality (BC) for a node or edge, denoted as $k$, quantifies its significance by aggregating the weights of all shortest paths that traverse through $k$. Specifically, the BC value for $k$ is determined by the formula:
             $$
             BC_k = \sum_{i \neq j} OD_k[i][j]
             $$        
             Here, $OD_k[i][j]$ represents the weight of the shortest path from node $i$ to node $j$ that includes $k$.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
            var measurement = new CMeasure(graph);
            var GPU = true;
            measurement.CalculateBC(ODWeightMatrix, GPU); 
            var BCN = measurement.BCNodes;
            var BCE = measurement.BCEdges;
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph)
            GPU = True
            measurement.CalculateBC(Array[Array[float]](ODWeightMatrix), GPU)
            BCN = measurement.BCNodes
            BCE = measurement.BCEdges
             ``` 
             </TabItem> 
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateBCGroup(System.Double[][],System.Collections.Generic.List{System.Collections.Generic.List{System.Int32}})">
             <summary>
             Calculates the betweenness centrality for edge groups, considering only paths with non-zero weights.
             </summary>
             <param name="ODWeightMatrix">The matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths between all pairs of nodes.</param>
             <param name="EdgeGroups">A list of edge groups, where each group contains the indices of edges considered together for betweenness centrality calculation.</param>
             <returns>An array of betweenness centrality values for each group, where each value represents the count of unique paths passing through any at least one in the group.</returns>
             <remarks>
             This method focuses on calculating the betweenness centrality for edges, assigning a weight of 1 for each considered path. The centrality value for a group of edges reflects the number of unique shortest paths that pass through at least one edge in the group. Paths corresponding to a weight of 0 in the <paramref name="ODWeightMatrix"/> are excluded from the calculation. 
            
             $$
             BC_{group} = \sum_{i \neq j} {\sigma_{ij}(group)}
             $$
            
             where $\sigma_{ij}(group)$ is the number of those paths passing through at least one edge in the group. 
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
            var measurement = new CMeasure(graph);   
            var BCEdgeGroup = measurement.CalculateBCGroup(ODWeightMatrix, EdgeGroups);  
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph)  
             BCEdgeGroup = measurement.CalculateBCGroup(Array[Array[float]](ODWeightMatrix), List[List[int]](EdgeGroups))
             ``` 
             </TabItem> 
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateBCWithAttractors(System.Double[][],System.Collections.Generic.List{System.Double})">
             
             <summary>
             Calculates betweenness centrality for edges (`BCEdgesAttractors`), emphasizing the influence of specified edge attractors within paths.
             </summary>
             <param name="ODWeightMatrix">The matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths between all pairs of nodes.</param>
             <param name="EdgeAttractorWeights">The attractor weights for each edge, quantifying their relative influence or attractiveness.</param>
             <remarks>
             This method enhances the concept of betweenness centrality by incorporating the notion of 'attractors'â€”specific qualities or weights assigned to edges that make them more 'attractive' or influential in the network's flow. The process unfolds in two main steps:
            
             1. **Total Attractor Weight on a Path**: The method sums up the attractor weights of all edges along each path.
            
             2. **Proportion of Individual Attractor Weight**: The centrality contribution of each edge is determined by its attractor weight relative to the total attractor weight of the path it's on. Specifically, for an edge with attractor weight $A$ on a path with total attractor weight $T$, its contribution to the path's centrality is proportionate to $\frac{A}{T}$ multiplied to the <paramref name="ODWeightMatrix"/> weight of a path.
            
             The following formula is used:   
             $$
             BC_a = \sum_{i \neq j}  OD_a[i][j] \times \left(\frac{EdgeAttractorWeights[a]}{PathTotalAttractorWeight}\right)
             $$
             In this formula, $ OD_a[i][j]$ denotes the weight of shortest path from node $i$ to node $j$ that includes attractor edge $a$. The $PathTotalAttractorWeight$ denotes the sum of edge weights in a path from node $i$ to node $j$ as in the list <paramref name="EdgeAttractorWeights"/>. 
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
            var measurement = new CMeasure(graph); 
            measurement.CalculateBCWithAttractors(ODWeightMatrix, EdgeAttractorWeightsList);
            var BCEdgesAttractors = measurement.BCEdgesAttractors;
              
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph)  
             measurement.CalculateBCWithAttractors(Array[Array[float]](ODWeightMatrix), List[float](EdgeAttractorWeightsList))
             BCEdgesAttractors = measurement.BCEdgesAttractors
             ``` 
             </TabItem> 
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateBCVisibility(System.Double[][],System.Int32[],System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{System.Int32}},System.Int32)">
             
             <summary>
             Calculates the visibility betweenness centrality, quantifying the network flow visibility from specified objects.
             </summary>
             <param name="ODWeightMatrix">The matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths in calculation.</param>
             <param name="RaysHitToObjects">A flat array linking each vantage point's ray to its visible object ID (or -1 if ray hits nothing).</param>
             <param name="EdgeToVantagePoints">A dictionary associating edges with their corresponding vantage points.</param>
             <param name="ObjectsCount">The number of objects included in the visibility analysis.</param>
             <returns>An array where each value represents the total visibility (summed OD weights) of network paths from an object's perspective.</returns>
             <remarks>
             This method evaluates how visible objects are to the paths within the network, effectively measuring how many unique paths have a view of each object. 
            
             The array <paramref name="RaysHitToObjects"/> effectively maps the visibility rays emitted from each vantage point to the objects they can see.  
             Each edge can have many vantage points. The sum of number of vantage points per each edge in the <paramref name="EdgeToVantagePoints"/> is a total number of vantage points. So the following is true:
             
            ```cs         
            int raysCountPerVantagePoint = RaysHitToObjects.Length / TotalNumberOfVantagePoints; 
             ```
             
             Visibility betweenness centrality for an object is calculated using the formula:
             $$
             BC_{object} = \sum_{i \neq j} OD_{visibleEdge}[i][j]
             $$
             where $OD_{visibleEdge}[i][j]$ is a weight of the shortest path from node $i$ to node $j$ that have at least one edge from which the $object$ is visible.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
            var measurement = new CMeasure(graph); 
            var BCVisibility = measurement.CalculateBCVisibility(ODWeightMatrix, RaysHitToObjects, EdgeToVantagePoints, ObjectsCount); 
              
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph)   
             BCVisibility = measurement.CalculateBCVisibility(Array[Array[float]](ODWeightMatrix), Array[int](RaysHitToObjects), Dictionary[int, List[int]](EdgeToVantagePoints), ObjectsCount)
             ``` 
             </TabItem> 
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateCC(System.Double[][],System.Int32,System.Boolean)">
             <summary>
             Calculates the closeness centrality for both nodes (`CCNodes`) and edges (`CCEdges`) based on the sum of shortest path distances from a specified weight matrix.
             </summary>
             <param name="ODWeightMatrix">The origin-destination matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths in calculation.</param>
             <param name="WeightMatrixId">The identifier of the weight matrix to use for distances retrieving. Default is 0.</param>
             <param name="GPU">A boolean indicating if GPU acceleration should be utilized. Set to <c>true</c> for GPU computation.</param>
             <remarks>
             This method diverges from the classical approach to calculating closeness centrality (CC). Instead of averaging the inverse of the distances, it directly sums the distances of the shortest paths as provided by the specified weight matrix. This approach highlights nodes and edges with lower aggregate distances across the network, potentially offering a more intuitive measure of centrality in certain contexts.
            
             The closeness centrality for a node $i$ is calculated using the formula:
             $$
             CC_i = \sum_{i \neq j} dist(i, j) \times OD[i][j] 
             $$
             Where $dist(i, j)$ denotes the shortest path distance between nodes $i$ and $j$ according to input <paramref name="WeightMatrixId"/> and $OD[i][j]$ the weight of this path. For edges the method identifies the initial directed or undirected edge in the path from node $i$ and accumulates the path distance to that edge ID.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
              var measurement = new CMeasure(graph);
              var GPU = true;
              measurement.CalculateCC(ODWeightMatrix, WeightMatrixId, GPU); 
              CCN = measurement.CCNodes;
              CCE = measurement.CCEdges; 
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph)
             GPU = True
             measurement.CalculateCC(Array[Array[float]](ODWeightMatrix), WeightMatrixId, GPU)
             CCN = measurement.CCNodes
             CCE = measurement.CCEdges
             ``` 
             </TabItem>  
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateCCNodesEdgesAverageCPU(System.Double[][],System.Int32)">
             <summary>
             Calculates closeness centrality for nodes and computes an average-based closeness centrality for edges.
             </summary>
             <param name="ODWeightMatrix">The origin-destination matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths in calculation.</param>
             <param name="WeightMatrixId">The identifier of the weight matrix to use for distances retrieving. Default is 0.</param>
             <remarks>
             This method calculates the closeness centrality (CC) for nodes, using the sum of distances from the ODWeightMatrix. For edges, instead of summing path distances directly, it computes an average closeness centrality value based on the closeness centrality of the nodes it connects.
            
             The formula for calculating the closeness centrality of a node:
             $$
             CC_{node} = \sum_{i \neq j} dist(i, j) \times OD[i][j] 
             $$
             Where $dist(i, j)$ denotes the shortest path distance between nodes $i$ and $j$ and $OD[i][j]$ the weight of this path.
             For an edge connecting nodes $i$ and $j$, the closeness centrality is derived as:
             $$
             CC_{edge} = \frac{CC_{node_i} + CC_{node_j}}{2}
             $$
             where $CC_{node_i}$ and $CC_{node_j}$ are the closeness centrality values of the nodes at either end of the edge.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
              var measurement = new CMeasure(graph); 
              measurement.CalculateCCNodesEdgesAverageCPU(ODWeightMatrix, WeightMatrixId); 
              CCN = measurement.CCNodes;
              CCE = measurement.CCEdges; 
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph) 
             measurement.CalculateCCNodesEdgesAverageCPU(Array[Array[float]](ODWeightMatrix), WeightMatrixId)
             CCN = measurement.CCNodes
             CCE = measurement.CCEdges
             ``` 
             </TabItem>  
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Grafit.CMeasure.CalculateCCNodesEdgesSumCPU(System.Double[][],System.Int32)">
             <summary>
             Calculates closeness centrality for nodes and edges, with edges centrality based on a detailed path distance calculation.
             </summary>
             <param name="ODWeightMatrix">The origin-destination matrix indicating the presence (some non-zero weight) or absence (0) of the shortest paths in calculation.</param>
             <param name="WeightMatrixId">The identifier of the weight matrix to use for distances retrieving. Default is 0.</param>
             <remarks>
             For nodes, closeness centrality is determined by the sum of shortest path distances according to input <paramref name="WeightMatrixId"/> multiplied by the corresponding weight from the  <paramref name="ODWeightMatrix"/> (`CCNodesDistanceSum`). For edges, closeness centrality involves a calculation that considers the path distance between edges, starting from the middle of an edge to another edge's middle. The process includes:
            
             1. Identifying the nodes at the ends of the origin ($o1$, $o2$) and destination edges ($d1$, $d2$).
             2. Calculating the shortest path distance from the end of the origin edge ($o2$) to the beginning of the target edge ($d1$).
             3. Adding half the distance of each edge to simulate starting from or arriving at the edge's midpoint. 
             4. Multiplying obtained distance by the corresponding weight from the  <paramref name="ODWeightMatrix"/>.
            
             Edge closeness centrality formula is the following (`CCEdgesDistanceSum`):
             $$
             CC_{edge_i} = \sum_{i \neq j} OD[o2][d1] \times  (dist(o2, d1) + \frac{dist(o1, o2)}{2} + \frac{dist(d1, d2)}{2})
             $$
             Where $edge_i$ as origin has nodes $o1$ and $o2$. And nodes $d1$ and $d2$ belong to an $edge_j$ as destination.
             
             This method also tracks the count of paths passing through each node (`CCNodesPathsCount`) and edge (`CCEdgesPathsCount`), enabling calculations of both classical and customized closeness centrality metrics.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
              var measurement = new CMeasure(graph); 
              measurement.CalculateCCNodesEdgesSumCPU(ODWeightMatrix, WeightMatrixId); 
              CCN = measurement.CCNodes;
              CCE = measurement.CCEdges; 
              
             var CCED = measurement.CCEdgesDistanceSum; 
             var CCEP = measurement.CCEdgesPathsCount;
             var CCND = measurement.CCNodesDistanceSum;
             var CCNP = measurement.CCNodesPathsCount;
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
             measurement = CMeasure(Graph) 
             measurement.CalculateCCNodesEdgesSumCPU(Array[Array[float]](ODWeightMatrix), WeightMatrixId)
             CCN = measurement.CCNodes
             CCE = measurement.CCEdges
             
             CCED = measurement.CCEdgesDistanceSum
             CCEP = measurement.CCEdgesPathsCount
             CCND = measurement.CCNodesDistanceSum
             CCNP = measurement.CCNodesPathsCount
             ``` 
             </TabItem>  
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="T:Grafit.AGraph`1">
            <summary>
            Represents an abstract base class for a graph data structure.
            </summary>
            <typeparam name="T">The type of elements stored in the graph's nodes. This allows for a graph
            to be generic and work with any data type.</typeparam>
        </member>
        <member name="P:Grafit.AGraph`1.Nodes">
            <summary>
            Gets the list of nodes in the graph.
            </summary>
            <value>The list of <see cref="T:Grafit.CNode"/> objects representing the nodes within the graph.</value>
        </member>
        <member name="P:Grafit.AGraph`1.NoValue">
            <summary>
            Gets the value used to represent an absence of value or an invalid state.
            </summary>
            <value>An integer indicating the absence of a valid value. By default set to -1.</value>
        </member>
        <member name="P:Grafit.AGraph`1.UndirectedEdges">
            <summary>
            Gets the collection of undirected edges in the graph.
            </summary>
            <value>A list of integer arrays, where each array contains two elements representing the node IDs.</value>
            <example>
            <code>
            var undirectedEdges = graph.UndirectedEdges;
            foreach (var edge in undirectedEdges)
            {
                Console.WriteLine($"Edge between node ID {edge[0]} and node ID {edge[1]}");
            }
            </code>
            </example>
        </member>
        <member name="P:Grafit.AGraph`1.NextMatrix">
            <summary>
            Gets the 'Successor' matrix used to reconstruct the paths between nodes in the graph.
            </summary>
            <value>A two-dimensional array of integers where each element [i][j] represents the next node 
            on the shortest path from node i to node j. </value>
        </member>
        <member name="P:Grafit.AGraph`1.AdjacencyMatrix">
            <summary>
            Gets the adjacency matrix representing the graph.
            </summary>
            <value>A two-dimensional array where each element [i][j] represents the presence (Edge Id) or absence (int.MaxValue) of an edge between node i and node j.</value>
        </member>
        <member name="P:Grafit.AGraph`1.NodesCount">
            <summary>
            Gets the total number of nodes in the graph.
            </summary>
            <value>The count of nodes currently present in the graph.</value>
        </member>
        <member name="P:Grafit.AGraph`1.WeightMatricesCount">
            <summary>
            Gets the total number of weight matrices in the graph.
            </summary>
            <value>The count of weight matrices that have been added to the graph.</value>
        </member>
        <member name="P:Grafit.AGraph`1.DirectedEdgesCount">
            <summary>
            Gets the total count of directed edges in the graph.
            </summary>
            <value>The count of directed edges, which is twice the number of undirected edges since each undirected edge is represented by two directed edges in opposite directions.</value>
        </member>
        <member name="P:Grafit.AGraph`1.UndirectedEdgesCount">
            <summary>
            Gets the total count of undirected edges in the graph.
            </summary>
            <value>The number of undirected edges.</value>
        </member>
        <member name="M:Grafit.AGraph`1.GetShortestPathDistance(System.Int32,System.Int32,System.Int32)">
             <summary>
             Retrieves the shortest path distance between two nodes using a specified weight matrix.
             </summary>
             <remarks> 
             This method directly accesses the specified weight matrix to retrieve the distance between the 'From' and 'To' nodes.
             If the 'From' and 'To' nodes are the same, it returns a default distance value defined by <see cref="F:Grafit.AGraph`1.TZero"/>,
             which represents the absence of distance or a path of length zero.
            
             Ensure that the nodes and weight matrix ID are valid before calling this method to avoid out-of-range errors.
             This method assumes that the shortest path distances have been computed and stored in the weight matrices. 
             See <see cref="M:Grafit.AGraph`1.APShortestPathsByOneWeight(System.Int32,System.Boolean,`0)"/> and <see cref="M:Grafit.AGraph`1.APShortestPathsByManyWeights(System.Int32,System.Int32,System.Boolean,`0)"/> 
             </remarks>
             <param name="FromNodeId">The ID of the starting node.</param>
             <param name="ToNodeId">The ID of the destination node.</param>
             <param name="WeightMatrixId">The identifier for the weight matrix to be used for lookup.</param>
             <returns>The shortest path distance of type <typeparamref name="T"/> (double or float) between the 'From' and 'To' nodes.
             Returns 0 if the 'From' and 'To' nodes are the same.</returns>  
        </member>
        <member name="M:Grafit.AGraph`1.GetShortestPathNodeIds(System.Int32,System.Int32)">
             <summary>
             Retrieves the shortest path as a list of node IDs between two specified node Ids.
             </summary>
             <remarks>
             This method returns the list of node IDs that form the shortest path from a starting node to a destination node. 
             Ensure that node IDs correspond to the primal graph (points), not to the dual graph nodes (lines).
             This method assumes that the shortest path distances have been computed and stored. 
             See <see cref="M:Grafit.AGraph`1.APShortestPathsByOneWeight(System.Int32,System.Boolean,`0)"/> and <see cref="M:Grafit.AGraph`1.APShortestPathsByManyWeights(System.Int32,System.Int32,System.Boolean,`0)"/>.
            
             If the starting and ending nodes are the same, the method returns a list containing only the
             starting node ID. 
            
             If a path cannot be found due to a broken path or if any intermediate node leads to a cycle 
             the method returns null.
             </remarks>
             <param name="From">The ID of the starting node (always a Primal one).</param>
             <param name="To">The ID of the destination node (always a Primal one).</param>
             <returns>A list of node IDs representing the shortest path from the starting node to the
             destination node, or null if no valid path exists.</returns>
        </member>
        <member name="M:Grafit.AGraph`1.GetShortestPathNodeAndEdgeIds(System.Int32,System.Int32)">
            <summary>
            Retrieves the shortest path between two nodes as both node and edge IDs, considering the graph's directionality.
            </summary>
            <remarks>
            This method first determines the shortest path by node IDs from the starting node to the destination node using <see cref="M:Grafit.AGraph`1.GetShortestPathNodeIds(System.Int32,System.Int32)"/>. It then translates this path into edge IDs, which represent the connections between consecutive nodes in the path. The method return edges result as directed or undirected edge ids, using the appropriate function (<see cref="M:Grafit.AGraph`1.GetDirectedEdgeIdByNodes(System.Int32,System.Int32)"/> or <see cref="M:Grafit.AGraph`1.GetUndirectedEdgeIdByNodes(System.Int32,System.Int32)"/>) to find edge IDs based on node pairs.
            Ensure that node IDs correspond to the primal graph (points), not to the dual graph nodes (lines).
            If the starting and ending nodes are the same, the method returns a node list containing only the
            starting node ID and empty edge list.  
            </remarks>
            <param name="FromNodeId">The ID of the starting node.</param>
            <param name="ToNodeId">The ID of the destination node.</param>
            <returns>A tuple containing two lists: the first list contains the node IDs in the shortest path, 
            and the second list contains the corresponding edge IDs.</returns>
            <example>
            <code>
            var (nodeIds, edgeIds) = graph.GetShortestPathNodeAndEdgeIds(fromNodeId, toNodeId, isDirected);
            </code>
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.GetShortestPathNodeAndEdgeIds(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Retrieves the shortest path between two nodes as both node and edge IDs, considering the graph's directionality.
            </summary>
            <remarks>
            This method is the same as <see cref="M:Grafit.AGraph`1.GetShortestPathNodeAndEdgeIds(System.Int32,System.Int32)"/> but result returned via out parameters. 
            </remarks>
            <param name="FromNodeId">The ID of the starting node.</param>
            <param name="ToNodeId">The ID of the destination node.</param>
            <param name="NodePathIds">An output parameter to hold the list of node IDs comprising the shortest path.</param>
            <param name="EdgePathIds">An output parameter to hold the list of edge IDs comprising the shortest path.</param> 
            <example>
            <code>
            graph.GetShortestPathNodeAndEdgeIds(fromNodeId, toNodeId, isDirected, out List&lt;int&gt; nodePath, out List&lt;int&gt; edgePath);
            </code>
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.GetAngleBetweenEdgesByNodesIds(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the angle between two edges defined by three node IDs.
            </summary>
            <param name="NodeId1">The ID of the first node, forming the start of the first edge.</param>
            <param name="NodeId2">The ID of the second node, shared by both edges.</param>
            <param name="NodeId3">The ID of the third node, forming the end of the second edge.</param>
            <returns>The absolute value of the angle (in degrees) between the two edges formed by the three nodes.</returns>
            <remarks>
            This method calculates the angle between two edges that share a common node. The edges are defined by the nodes
            (NodeId1, NodeId2) and (NodeId2, NodeId3). It uses the geometric positions of these nodes to compute the angle.
            </remarks> 
        </member>
        <member name="M:Grafit.AGraph`1.GetUndirectedEdgesAsNodeIdsFlatArray">
            <summary>
            Constructs a flat array representing undirected edges in a graph. Each pair of consecutive elements
            in the array represents an edge, where the first element of the pair is the ID of the first node, and
            the second element is the ID of the second node of the edge.
            </summary>
            <remarks>
            The array is structured so that for an edge at index i in the list of edges, the elements at
            positions 2*i and 2*i + 1 in the flat array correspond to the IDs of the first and second nodes
            of that edge, respectively.
            </remarks>
            <returns>
            A flat array of integers where each successive pair of elements represents the node IDs of an edge.
            </returns>
            <example> 
            var flatEdges = graph.GetUndirectedEdgesAsNodeIdsFlatArray();
            // If the graph contains an edge between nodes 1 and 2, and another edge between nodes 3 and 4,
            // the flatEdges array might look like [1, 2, 3, 4], assuming these are the only edges in the graph.
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.JoinForwardAndBackwardWeightsAsFlatArray(System.Int32)">
            <summary>
            Combines the forward and backward weight arrays of a specified weight matrix into a single, flat array.
            </summary>
            /// <remarks>
            This method is designed to work with both directed and undirected graphs. For directed graphs, it combines
            the weights of edges in both forward and backward directions, creating a flat array that represents
            concatenated the forward and backward weights. For undirected graphs, it simply returns
            the forward weights.
            </remarks>
            <param name="WeightMatrixId">The identifier of the weight matrix whose forward and backward weights are to be joined.
            This ID should correspond to an existing weight matrix within the graph.</param>
        </member>
        <member name="M:Grafit.AGraph`1.GetWeightMatrixById(System.Int32)">
            <summary>
            Retrieves a weight matrix associated with a given identifier. 
            </summary>
            <param name="Id">The identifier for the weight matrix to retrieve.</param>
            <returns>
            A 2-dimensional array of type <typeparamref name="T"/> (float or double), representing the weight matrix for the graph
            associated with the given ID. 
            </returns>
            <remarks>
            This method assumes that a collection of weight matrices is indexed by identifiers, equal to the order of adding the matrices 
            to the graph via <see cref="!:AddWeightMatrix(T[][])"/> function. 
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.IsAdjacent(System.Int32,System.Int32)">
            <summary>
            Determines whether two nodes in the graph are adjacent.
            </summary>
            <remarks>
            This method checks the adjacency matrix of the graph to determine if there is a direct edge between
            two nodes. 
            </remarks>
            <param name="Node1Id">The identifier of the first node.</param>
            <param name="Node2Id">The identifier of the second node.</param>
            <returns><c>true</c> if there is a direct edge between the two nodes; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Grafit.AGraph`1.IsNodeIdValid(System.Int32)">
            <summary>
            Checks if a given node ID is valid within the current graph.
            </summary>
            <remarks>
            This method verifies that the provided node ID is within the valid range of nodes in the graph,
            which is determined by the current count of nodes (<see cref="P:Grafit.AGraph`1.NodesCount"/>).  
            </remarks>
            <param name="NodeId">The ID of the node to validate.</param>
            <returns><c>true</c> if the node ID is less than the current count of nodes in the graph; otherwise, <c>false</c>.</returns>
            
        </member>
        <member name="M:Grafit.AGraph`1.GetUndirectedEdgeId(System.Int32)">
            <summary>
            Returns an udirected edge ID.
            </summary>
            <remarks>
            If <paramref name="EdgeId"/> is a directed edge ID, then a corresponding undirected edge ID is returned. 
            In case the <paramref name="EdgeId"/> corresponds to already undirected edge, it will be returned as it is. 
            </remarks>
            <param name="EdgeId">The ID of the edge.</param>
            <returns>The undirected edge ID.</returns> 
        </member>
        <member name="M:Grafit.AGraph`1.GetDirectedAndUndirectedEdgeIdByNodes(System.Int32,System.Int32)">
            <summary>
            Retrieves the directed and undirected edge IDs for a pair of nodes.
            </summary>
            <remarks>
            This method first retrieves the directed edge ID for the node pair specified by <paramref name="Node1Id"/>
            and <paramref name="Node2Id"/> using the <see cref="M:Grafit.AGraph`1.GetDirectedEdgeIdByNodes(System.Int32,System.Int32)"/> method. It then obtains the
            corresponding undirected edge ID by converting the directed edge ID via the <see cref="M:Grafit.AGraph`1.GetUndirectedEdgeId(System.Int32)"/>
            method. In case nodes are not adjacent int.MaxValue will be returned. 
            </remarks>
            <param name="Node1Id">The ID of the first node in the pair.</param>
            <param name="Node2Id">The ID of the second node in the pair.</param>
            <returns>A tuple containing the directed edge ID and the undirected edge ID for the specified node pair.</returns> 
            <example>
            <code>
            (int directedEdgeId, int undirectedEdgeId) = graph.GetDirectedAndUndirectedEdgeIdByNodes(node1Id, node2Id); 
            </code>
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.GetUndirectedEdgeIdByNodes(System.Int32,System.Int32)">
            <summary>
            Retrieves the undirected edge ID for an edge defined by two node IDs.
            </summary>
            <remarks>
            This method retrieves, first, the directed edge ID between the two specified nodes using
            <see cref="M:Grafit.AGraph`1.GetDirectedEdgeIdByNodes(System.Int32,System.Int32)"/> and then converts it to an undirected edge ID using
            <see cref="M:Grafit.AGraph`1.GetUndirectedEdgeId(System.Int32)"/>. In case nodes are not adjacent int.MaxValue will be returned.  
            </remarks>
            <param name="Node1Id">The ID of the first node.</param>
            <param name="Node2Id">The ID of the second node.</param>
            <returns>The undirected edge ID corresponding to the edge between the specified nodes.</returns> 
        </member>
        <member name="M:Grafit.AGraph`1.GetDirectedEdgeIdByNodes(System.Int32,System.Int32)">
            <summary>
            Retrieves the directed edge ID for an edge defined by two node IDs.
            </summary>
            <remarks>
            This method retrieves the directed edge ID between the two specified nodes using
            In case nodes are not adjacent int.MaxValue will be returned.  
            </remarks>
            <param name="Node1Id">The ID of the first node.</param>
            <param name="Node2Id">The ID of the second node.</param>
            <returns>The undirected edge ID corresponding to the edge between the specified nodes.</returns> 
        </member>
        <member name="M:Grafit.AGraph`1.GetOppositeEdgeId(System.Int32)">
            <summary>
            Retrieves the ID of the edge that is in the opposite direction to the given edge ID.
            </summary>
            <remarks>
            This method retrieves the edge Id that represents the same connection but in the opposite direction. 
            </remarks>
            <param name="EdgeId">The ID of the edge for which the opposite direction edge ID is to be found.</param>
            <returns>The ID of the edge that is in the opposite direction to the provided edge ID.</returns>
            <example>
            <code>
            int oppositeDirectionEdgeId = graph.GetOppositeEdgeId(edgeId);
            </code>
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.GetNodeIdsByEdgeId(System.Int32)">
            <summary>
            Retrieves the node IDs connected by a specified edge ID.
            </summary>
            <param name="EdgeId">The identifier of the edge.</param>
            <returns>A tuple containing the IDs of the two nodes connected by the edge. The order is (source, target) for directed edges.</returns>
            <remarks>
            This method returns the node IDs of a given edge ID for both directed and undirected edges.
            
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.GetSubgraphs">
            <summary>
            Retrieves all subgraphs within the graph as a list of lists, where each list contains the node IDs of a subgraph.
            </summary>
            <remarks>
            This method identifies and collects subgraphs by performing a depth-first search (DFS) starting from each unvisited node.        
            </remarks>
            <returns>A list of subgraphs, each represented as a list of node IDs indicating the nodes that form the subgraph.</returns>
            <example>
            <code>
            List&lt;List&lt;int&gt;&gt; subgraphs = graph.GetSubgraphs();
            foreach (var subgraph in subgraphs)
            {
                Console.WriteLine($"Subgraph: {string.Join(", ", subgraph)}");
            }
            </code>
            </example>
        </member>
        <member name="M:Grafit.AGraph`1.APShortestPathsByOneWeight(System.Int32,System.Boolean,`0)">
             <summary>
             Calculates all-pairs shortest paths in the graph using the Floyd-Warshall algorithm, based on a specified weight matrix and a tolerance for distance comparison.
             </summary>
             <remarks>
             This method employs the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes in the graph, considering a single weight for
             each edge as determined by the <paramref name="WeightMatrixId"/>. The <paramref name="Tolerance"/> parameter is used to treat distances as equal if they fall
             within this specified tolerance.
            
             The algorithm is executed on either the CPU or GPU, based on the <paramref name="GPU"/> parameter. When true, GPU acceleration is enabled.
             </remarks>
             <param name="WeightMatrixId">The identifier of the weight matrix to use for calculating distances with the Floyd-Warshall algorithm.</param>
             <param name="GPU">A boolean indicating if GPU acceleration should be utilized. Set to <c>true</c> for GPU computation.</param>
             <param name="Tolerance">The tolerance within which two distances are considered equal. The tolerance is of type <typeparamref name="T"/> (double or float).</param>
        </member>
        <member name="M:Grafit.AGraph`1.APShortestPathsByManyWeights(System.Int32,System.Int32,System.Boolean,`0)">
             <summary>
             Calculates all-pairs shortest paths in the graph using the Floyd-Warshall algorithm, based on 2 specified weight matrices and a tolerance for distance comparison.
             </summary>
             <remarks>
             This method employs the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes in the graph, considering two weights for
             each edge as determined by the <paramref name="WeightMatrixId"/> and <paramref name="RelativeMatrixId"/>.
             If the shortest path between a pair of nodes is equal within the margin defined by the <paramref name="Tolerance"/> parameter, the path with the 
             smaller distance, as determined by the <paramref name="RelativeMatrixId"/>, will be chosen as the solution. 
            
             The algorithm is executed on either the CPU or GPU, based on the <paramref name="GPU"/> parameter. When true, GPU acceleration is enabled.
             </remarks>
             <param name="WeightMatrixId">The identifier of the weight matrix to use for calculating distances with the Floyd-Warshall algorithm.</param>
             <param name="RelativeMatrixId">Identifier for an alternative weight matrix to resolve cases when shortest paths by main weight matrix are equal within the tolerance.</param>
             <param name="GPU">A boolean indicating if GPU acceleration should be utilized. Set to <c>true</c> for GPU computation.</param>
             <param name="Tolerance">The tolerance within which two distances are considered equal. The tolerance is of type <typeparamref name="T"/> (double or float).</param>
        </member>
        <member name="M:Grafit.AGraph`1.InitializeNextMatrix">
            <summary>
            Initializes the 'Successor' matrix used for pathfinding, setting default values for direct paths and marking self-paths as invalid.
            </summary>
            <remarks>
            This method sets up the 'Successor' matrix which is used for reconstructing paths after running pathfinding algorithms. Each cell
            in the matrix indicates the next node on the shortest path from origin node to destination node. 
            Self-paths, or paths from a node to itself, are marked as invalid with a default value of -1 ( <see cref="P:Grafit.AGraph`1.NoValue"/>), indicating that such paths should not
            be considered in path reconstruction.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.AddEmptyWeightMatrix(`0,System.Boolean)">
             <summary>
             Adds new edges weights and a corresponding weight matrix to the graph, initializing all weights.
             </summary>
             <remarks>
             This method creates a new weight matrix where each edge's weight to itself is set to the given <paramref name="DiagonalValue"/>, 
             by default double.MaxValue, indicating invalid travel from a node to itself. All other weights are initialized to represent infinite distance (double.MaxValue).
            
             Following initialization, the method creates a list of undirected edge weights (forward), setting all to represent infinite distance. 
             For directed graphs, a separate list for opposite direction edge weights (backward) is also created, applying the same infinite distance initialization. 
             Note, that empty weight matrix can be added only if graph already have nodes and edges and weighted by at least one matrix.
             </remarks>
             <param name="DiagonalValue">The weight value for paths from a node to itself within the matrix, indicating the self-path cost. By default double.MaxValue.</param>
             <returns>The index of the newly added weight matrix, which can be used to reference it in future operations.</returns> 
        </member>
        <member name="M:Grafit.AGraph`1.AddWeightMatrix(`0[][],System.Boolean)">
            <summary>
            Adds a new weight matrix to the graph and updates corresponding edge weights.
            </summary>
            <param name="WeightMatrix">The weight matrix to be added, representing the weights between nodes in the graph.</param>
            <returns>The identifier of the newly added weight matrix.</returns> 
            <remarks>
            This method adds the specified weight matrix to the graph. For directed graphs, both directions of edge weights (forward and backward) 
            are created based on the input weight matrix. For undirected graphs, only undirected edge weights (forward) are created.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.RemoveWeightMatrix(System.Int32)">
            <summary>
            Removes a specified weight matrix and its associated edge weights from the graph.
            </summary>
            <param name="WeightMatrixId">The identifier of the weight matrix to be removed.</param>
            <remarks>
            The method removes the weight matrix along with the associated undirected (forward) edge weights. 
            For directed graphs, edges in opposite direction (backward) weights corresponding to the same weight matrix ID are also removed.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.SetWeightMatrixValue(`0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the weight value for an edge in a specified weight matrix.
            </summary>
            <param name="Value">The weight value to set for the edge.</param>
            <param name="FromNodeId">The ID of the source node of the edge.</param>
            <param name="ToNodeId">The ID of the destination node of the edge.</param>
            <param name="WeightMatrixId">The identifier of the weight matrix where the weight value is to be set.</param>
            <remarks>
            This method updates the weight of the edge from the origin node to the destination node in the specified weight matrix. 
            Note that it updates only matrix without updating the edges lists. This is helpful for dual graphs only. 
            In other cases the <see cref="M:Grafit.AGraph`1.SetWeightMatrixAndEdgeValue(`0,System.Int32,System.Int32,System.Int32)"/> should be used.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.SetWeightMatrixAndEdgeValue(`0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the weight for a specific edge in both the weight matrix and the corresponding edge list.
            </summary>
            <param name="Value">The weight value to set for the edge.</param>
            <param name="FromNodeId">The ID of the source node of the edge.</param>
            <param name="ToNodeId">The ID of the destination node of the edge.</param>
            <param name="WeightMatrixId">The identifier of the weight matrix where the weight value is to be set.</param>
            <remarks>
            Updates the specified edge's weight in the weight matrix and then adjusts the corresponding edge's value in the edge list. 
            This ensures consistency between the graph's internal representations of edge weights. 
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.GetEdgeValue(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the weight value of an edge between two specified nodes by the given weight matrix ID.
            </summary>
            <param name="FromNodeId">The ID of the source node of the edge.</param>
            <param name="ToNodeId">The ID of the destination node of the edge.</param>
            <param name="WeightMatrixId">The identifier of the weight matrix where the weight value is to be set.</param>
            <returns>The weight value of the edge as specified in the edge list.</returns>
            <remarks>
            The method retrieves the weight from the edge weights list, ensuring compatibility with both directed and undirected graph structures.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.GetEdgeValue(System.Int32,System.Int32)">
            <summary>
            Retrieves the weight value of an edge between two specified nodes by the given weight matrix ID.
            </summary>
            <param name="EdgeId">The ID of the edge for which the weight is retrieved.</param> 
            <param name="WeightMatrixId">The identifier of the weight matrix where the weight value is to be set.</param>
            <returns>The weight value of the edge as specified in the edge list.</returns>
            <remarks>
            The method retrieves the weight from the edge weights list, ensuring compatibility with both directed and undirected graph structures.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.GetWeightMatrixValue(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the weight value of an edge between two specified nodes from the given weight matrix ID.
            </summary>
            <param name="FromNodeId">The ID of the source node of the edge.</param>
            <param name="ToNodeId">The ID of the destination node of the edge.</param>
            <param name="WeightMatrixId">The identifier of the weight matrix where the weight value is to be set.</param>
            <returns>The weight value of the edge as specified in the weight matrix.</returns>
            <remarks>
            The method retrieves the weight from the weight matrix.
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.FillWeightMatrixBySPRestore(System.Int32[],System.Boolean)">
            <summary>
            Fills weight matrices with distances of shortest paths, reconstructed from the 'Successor' matrix, using specified weight matrix IDs.
            </summary>
            <param name="WeightMatrixIds">An array of identifiers for the weight matrices to be updated with shortest path distances.</param>
            <param name="GPU">A boolean indicating if GPU acceleration should be utilized. Set to <c>true</c> for GPU computation.</param>
            <remarks>
            This method utilizes the 'Successor' matrix, which is calculated in previous steps, to retrace the shortest paths between all pairs of nodes
            and measure the existed paths according to other weights specified in parameter <paramref name="WeightMatrixIds"/>.
            
            Depending on the <paramref name="GPU"/> parameter, this process is performed either on the CPU or the GPU. 
            </remarks>
        </member>
        <member name="M:Grafit.AGraph`1.ConvertDoubleToFloatJaggedArray(System.Double[][])">
            <summary>
            Converts a jagged array of doubles to a jagged array of floats.
            </summary>
            <param name="DoubleArray">The jagged array of doubles to convert.</param>
            <returns>A jagged array of floats corresponding to the input double array.</returns>
            <remarks>
            This method converting each value in double array to float and populating a new jagged array of floats.
            </remarks>
        </member>
        <member name="T:Grafit.CNode">
            <summary>
            Represents a node in a graph.
            </summary>
            <remarks>
            The <c>CNode</c> class.
            </remarks>
        </member>
        <member name="M:Grafit.CNode.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Dual Node
            </summary>
            <param name="Id">Dual Node Id</param>
            <param name="PrimId1">Primal Edge Id (From)</param>
            <param name="PrimId2">Primal Edge Id (To)</param>
        </member>
        <member name="T:Grafit.ISpatialGraph`3">
            <summary>
            Defines a contract for a spatial graph that includes nodes and edges with geometric and weight properties.
            </summary>
        </member>
        <member name="P:Grafit.ISpatialGraph`3.BBMinPoint">
            <summary>
            Gets the minimum bounding box point of the graph's nodes.
            </summary>
            <value>The lower-left corner point of the graph's nodes bounding box.</value> 
        </member>
        <member name="P:Grafit.ISpatialGraph`3.BBMaxPoint">
            <summary>
            Gets the maximum bounding box point of the graph's nodes.
            </summary>
            <value>The upper-right corner point of the graph's nodes bounding box.</value> 
        </member>
        <member name="P:Grafit.ISpatialGraph`3.NodesGeometryList">
            <summary>
            Gets the list of geometric representations for all nodes in the graph.
            </summary>
            <value>A list of <see cref="!:NodeObject"/> instances, each representing the geometric data of a node.</value>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.GetNodeGeometryItem(System.Int32)">
            <summary>
            Retrieves the geometric representation of a node by its ID.
            </summary>
            <param name="NodeId">The ID of the node whose geometric data is to be retrieved.</param>
            <returns>A <see cref="!:NodeObject"/> instance representing the geometric information of the specified node.</returns>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.IsPointInsideBBox(Grafit.APoint)">
            <summary>
            Determines if a given point is located inside the bounding box of the graph.
            </summary>
            <param name="Point">The point to check.</param>
            <returns>True if the point is within the bounding box; otherwise, false.</returns>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.ClosestNodeToPoint(Grafit.APoint)">
            <summary>
            Finds the closest node ID to a given point and calculates the distance to it.
            </summary>
            <param name="Point">The point for which to find the closest node ID.</param>
            <returns>A tuple containing the ID of the closest node and the distance to that node.</returns>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.NodeObjectById(System.Int32)">
            <summary>
            Retrieves the spatial point representation of a node by its ID.
            </summary>
            <param name="Id">The ID of the node whose spatial representation is requested.</param>
            <returns>A point representing the spatial location of the specified node.</returns>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.GenerateUndirectedEdgeGeometry(System.Func{Grafit.AWPoint,Grafit.AWPoint,`1})">
            <summary>
            Generates a list of undirected edge objects based on the spatial point representations of nodes.
            </summary>
            <param name="EdgeFromPoints">A function that takes two points (representing the endpoints of an edge) and returns an <see cref="!:EdgeObject"/> representing the edge between those points.</param>
            <returns>A list of <see cref="!:EdgeObject"/> instances representing the undirected edges generated from the spatial points of nodes.</returns>
            <remarks>
            Since only node objects as points are stored within the graph, edges geometry are dynamically generated from this data.
            </remarks>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.GenerateDirectedEdgeGeometry(System.Func{Grafit.AWPoint,Grafit.AWPoint,`1})">
            <summary>
            Generates a list of directed edge objects based on the spatial point representations of nodes.
            </summary>
            <param name="EdgeFromPoints">A function that takes two points (representing the endpoints of an edge) and returns an <see cref="!:EdgeObject"/> representing the edge between those points.</param>
            <returns>A list of <see cref="!:EdgeObject"/> instances representing the directed edges generated from the spatial points of nodes.</returns>
            <remarks>
            Since only node objects as points are stored within the graph, edges geometry are dynamically generated from this data.
            </remarks>
        </member>
        <member name="M:Grafit.ISpatialGraph`3.GenerateDirectedEdgeGeometryAsTwoInternalLists``1(System.Func{Grafit.AWPoint,Grafit.AWPoint,Grafit.AWLine})">
            <summary>
            Generates geometry for directed edges as two separate lists, one for each direction.
            </summary>
            <typeparam name="TL">The type of the line object representing the edge geometry.</typeparam>
            <param name="EdgeFromPoints">A function that creates an edge object from two points, representing the start and end points of an edge.</param>
            <returns>A tuple containing two lists of type <typeparamref name="TL"/>. The first list contains edge geometries for the forward direction, 
            and the second list contains geometries for the opposite direction. </returns>
            <remarks>
            Since only node objects as points are stored within the graph, edges geometry are dynamically generated from this data.
            </remarks>
        </member>
        <member name="T:Grafit.CPrimalDirectedGraph">
            <summary>
            A directed, primal graph where nodes represent points in space and edges represent lines between these points.
            </summary>
            <remarks>
            The `CPrimalDirectedGraph` class models a directed graph tailored for spatial analysis, where each node corresponds to a specific point with coordinates, 
            and each edge represent a line with both directions.
            </remarks>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.#ctor(Grafit.GraphElements{Grafit.AWPoint})">
             <summary>
             Initializes a new primal directed graph from specified graph elements.
             </summary>
             <param name="GraphElements">The graph elements that represent the spatial data.</param>
             <remarks>
             This constructor uses the <see cref="T:Grafit.GraphElements`1"/> object, which contains 
             spatial points as nodes and lines as edges, along with their default weight as line length.
             </remarks>
             <example>
             <code>
             <![CDATA[
             <Tabs> 
             <TabItem value = "c#" label="C#" default>
            ```cs 
            var graphElements = GeometryToGraphElements.GetNodesAndEdgesFromLines(lineGeometry, out double[][] edgeLengths); 
            primalGraph = new CPrimalDirectedGraph(graphElements);
             ```
             </TabItem>
             <TabItem value = "python" label="Python">
             ```py
            graphElements, edgeLengths = GeometryToGraphElements.GetNodesAndEdgesFromLines(lineGeometry)
            primalGraph = CPrimalDirectedGraph(graphElements)
             ``` 
             </TabItem> 
             </Tabs>
             ]]>
             </code>
             </example>
        </member>
        <member name="P:Grafit.CPrimalDirectedGraph.NodesGeometryList">
            <inheritdoc/>
        </member>
        <member name="P:Grafit.CPrimalDirectedGraph.BBMinPoint">
            <inheritdoc/>
        </member>
        <member name="P:Grafit.CPrimalDirectedGraph.BBMaxPoint">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetNodeGeometryItem(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.IsPointInsideBBox(Grafit.APoint)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.NodeObjectById(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.ClosestNodeToPoint(Grafit.APoint)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GenerateUndirectedEdgeGeometry(System.Func{Grafit.AWPoint,Grafit.AWPoint,Grafit.AWLine})">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GenerateDirectedEdgeGeometryAsTwoInternalLists``1(System.Func{Grafit.AWPoint,Grafit.AWPoint,Grafit.AWLine})">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GenerateDirectedEdgeGeometry(System.Func{Grafit.AWPoint,Grafit.AWPoint,Grafit.AWLine})">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetPrimalNodesGeometry">
            <summary>
            Retrieves the points of all primal nodes in the graph.
            </summary>
            <returns>An enumerable collection of points, each representing the geometry of a primal node.</returns> 
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetShortestPathDistance(System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetShortestPathNodeIds(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetShortestPathNodeAndEdgeIds(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetShortestPathNodeAndEdgeIds(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32}@,System.Collections.Generic.List{System.Int32}@)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetNodesFromEdgeId(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Grafit.CPrimalDirectedGraph.GetAngleBetweenEdgesByNodesIds(System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
    </members>
</doc>
